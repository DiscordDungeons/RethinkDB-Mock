// Generated by CoffeeScript 1.12.4
var Query, Result, actions, define, getArity, getType, isArray, isArrayOrObject, isConstructor, isNullError, methods, setType, sliceArray, statics, utils, variadic;

isConstructor = require("isConstructor");

sliceArray = require("sliceArray");

setType = require("setType");

actions = require("./actions");

utils = require("./utils");

isArray = Array.isArray;

define = Object.defineProperty;

Query = function(parent, type) {
  var query;
  query = function(key) {
    return query.bracket(key);
  };
  if (parent) {
    query._db = parent._db;
    query._type = type || parent._type;
    query._parent = parent;
  } else {
    query._db = null;
    query._type = type || null;
  }
  return setType(query, Query);
};

Result = require("./Result")(Query);

variadic = function(keys) {
  return keys.split(" ").forEach(function(key) {
    methods[key] = function() {
      return this._then(key, arguments);
    };
  });
};

methods = {};

methods["default"] = function(value) {
  return Query._default(this, value);
};

methods["do"] = function(callback) {
  return Result(this)._do(callback);
};

variadic("eq ne gt lt ge le or and add sub mul div");

methods.nth = function(index) {
  return this._then("nth", arguments);
};

methods.bracket = function(key) {
  return this._then("bracket", arguments);
};

methods.getField = function(field) {
  return this._then("getField", arguments);
};

variadic("hasFields");

methods.offsetsOf = function(value) {
  return this._then("offsetsOf", arguments);
};

methods.orderBy = function(field) {
  return this._then("orderBy", arguments);
};

methods.filter = function(filter, options) {
  return this._then("filter", arguments);
};

variadic("slice merge pluck without");

methods.typeOf = function() {
  return this._then("typeOf");
};

methods.update = function(patch) {
  return this._then("update", arguments);
};

methods.replace = function(values) {
  return this._then("replace", arguments);
};

methods["delete"] = function() {
  return this._then("delete");
};

methods.run = function() {
  return Promise.resolve().then(this._run.bind(this));
};

methods.then = function(onFulfilled) {
  return this.run().then(onFulfilled);
};

methods["catch"] = function(onRejected) {
  return this.run()["catch"](onRejected);
};

methods._then = function(action, args) {
  var self;
  self = Query(this, getType(action));
  self._action = action;
  if (args) {
    self._args = args;
    self._parseArgs();
  }
  return self;
};

methods._parseArgs = function() {
  var args, arity, index;
  arity = getArity(this._action);
  args = isArray(this._args) ? this._args : sliceArray(this._args);
  if (args.length < arity[0]) {
    throw Error("`" + this._action + "` takes at least " + arity[0] + " argument" + (arity[0] === 1 ? "" : "s") + ", " + args.length + " provided");
  }
  if (args.length > arity[1]) {
    throw Error("`" + this._action + "` takes at most " + arity[1] + " argument" + (arity[1] === 1 ? "" : "s") + ", " + args.length + " provided");
  }
  index = -1;
  while (++index < args.length) {
    if (!utils.isQuery(args[index])) {
      args[index] = Query._expr(args[index]);
    }
  }
  this._args = args;
};

methods._eval = function(ctx) {
  var action, args, arity, result;
  action = this._action;
  result = this._parent._eval(ctx);
  if (isConstructor(action, Function)) {
    return action.call(ctx, result);
  }
  if (isConstructor(action, String)) {
    args = utils.resolve(this._args);
    arity = getArity(action)[1];
    result = arity === 0 ? actions[action].call(ctx, result) : arity === 1 ? actions[action].call(ctx, result, args[0]) : arity === 2 ? actions[action].call(ctx, result, args[0], args[1]) : actions[action].call(ctx, result, args);
  }
  ctx.type = isConstructor(this._type, Function) ? this._type.call(this, ctx, args) : this._type;
  return result;
};

methods._run = function(ctx) {
  var result;
  if (ctx == null) {
    ctx = {};
  }
  ctx.db = this._db;
  result = this._eval(ctx);
  if (/TABLE|SEQUENCE|SELECTION/.test(ctx.type)) {
    return utils.clone(result);
  }
  return result;
};

statics = {};

statics._default = function(parent, value) {
  var self;
  if (!utils.isQuery(value)) {
    value = Query._expr(value);
  }
  self = Query(parent);
  self._eval = function(ctx) {
    var error, result;
    try {
      result = parent._eval(ctx);
    } catch (error1) {
      error = error1;
      if (!isNullError(error)) {
        throw error;
      }
    }
    return result != null ? result : value._eval(ctx);
  };
  return self;
};

statics._expr = function(expr) {
  var self, values;
  if (expr === void 0) {
    throw Error("Cannot convert `undefined` with r.expr()");
  }
  if (isConstructor(expr, Number) && !isFinite(expr)) {
    throw Error("Cannot convert `" + expr + "` to JSON");
  }
  self = Query();
  if (utils.isQuery(expr)) {
    self._eval = function(ctx) {
      return expr._run(ctx);
    };
  } else if (isArrayOrObject(expr)) {
    values = expr;
    expr = isArray(values) ? [] : {};
    Object.keys(values).forEach(function(key) {
      var value;
      value = values[key];
      if (!utils.isQuery(value)) {
        expr[key] = Query._expr(value);
        return;
      }
      if (value._type === "DATUM") {
        expr[key] = value;
        return;
      }
      throw Error("Expected type DATUM but found " + value._type);
    });
    self._type = "DATUM";
    self._eval = function(ctx) {
      ctx.type = this._type;
      return utils.resolve(expr);
    };
  } else {
    self._type = "DATUM";
    self._eval = function(ctx) {
      ctx.type = this._type;
      return expr;
    };
  }
  return self;
};

Object.keys(methods).forEach(function(key) {
  return define(Query.prototype, key, {
    value: methods[key],
    writable: true
  });
});

Object.keys(statics).forEach(function(key) {
  return define(Query, key, {
    value: statics[key]
  });
});

module.exports = Query;

isArrayOrObject = function(value) {
  return isArray(value) || isConstructor(value, Object);
};

isNullError = function(error) {
  return !error || /(Index out of bounds|No attribute|null)/i.test(error.message);
};

getType = (function() {
  var sequential, types;
  sequential = function(ctx) {
    if (/TABLE|SEQUENCE/.test(ctx.type)) {
      return "SEQUENCE";
    }
    return "DATUM";
  };
  types = {
    eq: "DATUM",
    ne: "DATUM",
    gt: "DATUM",
    lt: "DATUM",
    ge: "DATUM",
    le: "DATUM",
    or: "DATUM",
    and: "DATUM",
    add: "DATUM",
    sub: "DATUM",
    mul: "DATUM",
    div: "DATUM",
    nth: function(ctx) {
      if (/TABLE|SEQUENCE/.test(ctx.type)) {
        return "SELECTION";
      }
      return "DATUM";
    },
    bracket: function(ctx, args) {
      if (!isConstructor(args[0], String)) {
        if (/TABLE|SEQUENCE/.test(ctx.type)) {
          return "SELECTION";
        }
      }
      return "DATUM";
    },
    getField: "DATUM",
    hasFields: sequential,
    offsetsOf: "DATUM",
    orderBy: sequential,
    filter: sequential,
    fold: null,
    count: "DATUM",
    limit: sequential,
    slice: sequential,
    merge: "DATUM",
    pluck: "DATUM",
    without: "DATUM",
    typeOf: "DATUM",
    update: "DATUM",
    replace: "DATUM",
    "delete": "DATUM"
  };
  return function(action) {
    return types[action];
  };
})();

getArity = (function() {
  var arity;
  arity = {
    eq: [1, 2e308],
    ne: [1, 2e308],
    gt: [1, 2e308],
    lt: [1, 2e308],
    ge: [1, 2e308],
    le: [1, 2e308],
    or: [1, 2e308],
    and: [1, 2e308],
    add: [1, 2e308],
    sub: [1, 2e308],
    mul: [1, 2e308],
    div: [1, 2e308],
    nth: [1, 1],
    bracket: [1, 1],
    getField: [1, 1],
    hasFields: [1, 2e308],
    offsetsOf: [1, 1],
    orderBy: [1, 1],
    filter: [1, 2],
    fold: [2, 2],
    count: [0, 0],
    limit: [1, 1],
    slice: [1, 2e308],
    merge: [1, 2e308],
    pluck: [1, 2e308],
    without: [1, 2e308],
    typeOf: [0, 0],
    getAll: [1, 2e308],
    insert: [1, 2],
    update: [1, 1],
    replace: [1, 1],
    "delete": [0, 0]
  };
  return function(action) {
    return arity[action];
  };
})();
