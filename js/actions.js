// Generated by CoffeeScript 1.12.4
var actions, deleteRow, deleteRows, equals, isArray, isConstructor, isFalse, seq, sortAscending, sortDescending, updateRow, updateRows, utils;

isConstructor = require("isConstructor");

utils = require("./utils");

seq = require("./utils/seq");

isArray = Array.isArray;

actions = exports;

actions.eq = function(result, args) {
  return equals(result, args);
};

actions.ne = function(result, args) {
  return !equals(result, args);
};

actions.gt = function(result, args) {
  var arg, i, len, prev;
  prev = result;
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    if (prev <= arg) {
      return false;
    }
    prev = arg;
  }
  return true;
};

actions.lt = function(result, args) {
  var arg, i, len, prev;
  prev = result;
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    if (prev >= arg) {
      return false;
    }
    prev = arg;
  }
  return true;
};

actions.ge = function(result, args) {
  var arg, i, len, prev;
  prev = result;
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    if (prev < arg) {
      return false;
    }
    prev = arg;
  }
  return true;
};

actions.le = function(result, args) {
  var arg, i, len, prev;
  prev = result;
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    if (prev > arg) {
      return false;
    }
    prev = arg;
  }
  return true;
};

actions.or = function(result, args) {
  var arg, i, len;
  if (!isFalse(result)) {
    return result;
  }
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    if (!isFalse(arg)) {
      return arg;
    }
  }
  return args.pop();
};

actions.and = function(result, args) {
  var arg, i, len;
  if (isFalse(result)) {
    return result;
  }
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    if (isFalse(arg)) {
      return arg;
    }
  }
  return args.pop();
};

actions.add = function(result, args) {
  var arg, i, len, total, type;
  type = utils.typeOf(result);
  if (!/ARRAY|NUMBER|STRING/.test(type)) {
    throw Error("Expected type ARRAY, NUMBER, or STRING but found " + type);
  }
  total = result;
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    utils.expect(arg, type);
    if (type === "ARRAY") {
      total = total.concat(arg);
    } else {
      total += arg;
    }
  }
  return total;
};

actions.sub = function(result, args) {
  var arg, i, len, total;
  utils.expect(result, "NUMBER");
  total = result;
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    utils.expect(arg, "NUMBER");
    total -= arg;
  }
  return null;
};

actions.mul = function(result, args) {
  var arg, i, len, total;
  utils.expect(result, "NUMBER");
  total = result;
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    utils.expect(arg, "NUMBER");
    total *= arg;
  }
  return null;
};

actions.div = function(result, args) {
  var arg, i, len, total;
  utils.expect(result, "NUMBER");
  total = result;
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    utils.expect(arg, "NUMBER");
    total /= arg;
  }
  return null;
};

actions.nth = function(result, index) {
  utils.expect(result, "ARRAY");
  utils.expect(index, "NUMBER");
  if (index < -1 && /TABLE|SEQUENCE/.test(this.type)) {
    throw Error("Cannot use an index < -1 on a stream");
  }
  return seq.nth(result, index);
};

actions.bracket = function(result, key) {
  var type;
  type = utils.typeOf(key);
  if (type === "NUMBER") {
    if (key < -1 && /TABLE|SEQUENCE/.test(this.type)) {
      throw Error("Cannot use an index < -1 on a stream");
    }
    return seq.nth(result, key);
  }
  if (type !== "STRING") {
    throw Error("Expected NUMBER or STRING as second argument to `bracket` but found " + type);
  }
  type = utils.typeOf(result);
  if (type === "ARRAY") {
    return seq.getField(result, key);
  }
  if (type === "OBJECT") {
    return utils.getField(result, key);
  }
  throw Error("Expected ARRAY or OBJECT as first argument to `bracket` but found " + type);
};

actions.getField = function(result, attr) {
  var type;
  utils.expect(attr, "STRING");
  type = utils.typeOf(result);
  if (type === "ARRAY") {
    return seq.getField(result, attr);
  }
  if (type === "OBJECT") {
    return utils.getField(result, attr);
  }
  throw Error("Expected ARRAY or OBJECT but found " + type);
};

actions.hasFields = function(result, attrs) {
  var attr, i, len, type;
  attrs = utils.flatten(attrs);
  for (i = 0, len = attrs.length; i < len; i++) {
    attr = attrs[i];
    utils.expect(attr, "STRING");
  }
  type = utils.typeOf(result);
  if (type === "ARRAY") {
    return seq.hasFields(result, attrs);
  }
  if (type === "OBJECT") {
    return utils.hasFields(result, attrs);
  }
  throw Error("Expected ARRAY or OBJECT but found " + type);
};

actions.offsetsOf = function(array, value) {
  var i, index, len, offsets, value2;
  utils.expect(array, "ARRAY");
  if (value === void 0) {
    throw Error("Argument 1 to offsetsOf may not be `undefined`");
  }
  if (utils.isQuery(value)) {
    value = value._run();
  }
  if (isConstructor(value, Function)) {
    throw Error("Function argument not yet implemented");
  }
  offsets = [];
  for (index = i = 0, len = array.length; i < len; index = ++i) {
    value2 = array[index];
    if (utils.equals(value2, value)) {
      offsets.push(index);
    }
  }
  return offsets;
};

actions.orderBy = function(array, value) {
  var DESC, index, sorter;
  utils.expect(array, "ARRAY");
  if (isConstructor(value, Object)) {
    DESC = value.DESC, index = value.index;
  } else if (isConstructor(value, String)) {
    index = value;
  }
  sorter = DESC ? sortDescending(index) : sortAscending(index);
  utils.expect(index, "STRING");
  return array.slice().sort(sorter);
};

actions.filter = function(array, filter, options) {
  utils.expect(array, "ARRAY");
  return seq.filter(array, filter, options);
};

actions.fold = function() {
  throw Error("Not implemented");
};

actions.count = function(array) {
  utils.expect(array, "ARRAY");
  return array.length;
};

actions.limit = function(array, count) {
  utils.expect(array, "ARRAY");
  if (utils.isQuery(count)) {
    count = count._run();
  }
  utils.expect(count, "NUMBER");
  if (count < 0) {
    throw Error("Cannot call `limit` with a negative number");
  }
  return array.slice(0, count);
};

actions.slice = function(result, args) {
  var type;
  type = utils.typeOf(result);
  if (type === "ARRAY") {
    return seq.slice(result, args);
  }
  if (type === "BINARY") {
    throw Error("`slice` does not support BINARY values (yet)");
  }
  if (type === "STRING") {
    throw Error("`slice` does not support STRING values (yet)");
  }
  throw Error("Expected ARRAY, BINARY, or STRING, but found " + type);
};

actions.merge = function(result, args) {
  var type;
  type = utils.typeOf(result);
  if (type === "ARRAY") {
    return seq.merge(result, args);
  }
  if (type === "OBJECT") {
    return utils.merge(result, args);
  }
  throw Error("Expected ARRAY or OBJECT but found " + type);
};

actions.pluck = function(result, args) {
  var type;
  type = utils.typeOf(result);
  if (type === "ARRAY") {
    return seq.pluck(result, args);
  }
  if (type === "OBJECT") {
    return utils.pluck(result, args);
  }
  throw Error("Expected ARRAY or OBJECT but found " + type);
};

actions.without = function(result, args) {
  var type;
  args = utils.flatten(args);
  type = utils.typeOf(result);
  if (type === "ARRAY") {
    return seq.without(result, args);
  }
  if (type === "OBJECT") {
    return utils.without(result, args);
  }
  throw Error("Expected ARRAY or OBJECT but found " + type);
};

actions.typeOf = utils.typeOf;

actions.update = function(result, patch) {
  if (isArray(result)) {
    return updateRows.call(this, result, patch);
  }
  return updateRow.call(this, result, patch);
};

actions.replace = function(row, values) {
  var table;
  if (this.type !== "SELECTION") {
    throw Error("Expected type SELECTION but found " + this.type);
  }
  table = this.db._tables[this.tableId];
  if (values === null) {
    if (row === null) {
      return {
        deleted: 0,
        skipped: 1
      };
    }
    table.splice(this.rowIndex, 1);
    return {
      deleted: 1,
      skipped: 0
    };
  }
  if ("OBJECT" !== utils.typeOf(values)) {
    throw Error("Inserted value must be an OBJECT (got " + (utils.typeOf(values)) + ")");
  }
  if (!values.hasOwnProperty("id")) {
    throw Error("Inserted object must have primary key `id`");
  }
  if (values.id !== this.rowId) {
    throw Error("Primary key `id` cannot be changed");
  }
  if (row === null) {
    table.push(utils.clone(values));
    return {
      inserted: 1
    };
  }
  if (utils.equals(row, values)) {
    return {
      replaced: 0,
      unchanged: 1
    };
  }
  table[this.rowIndex] = utils.clone(values);
  return {
    replaced: 1,
    unchanged: 0
  };
};

actions["delete"] = function(result) {
  if (isArray(result)) {
    return deleteRows.call(this, result);
  }
  return deleteRow.call(this, result);
};

equals = function(result, args) {
  var arg, i, len;
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    if (!utils.equals(result, arg)) {
      return false;
    }
  }
  return true;
};

isFalse = function(value) {
  return (value === null) || (value === false);
};

sortAscending = function(index) {
  return function(a, b) {
    if (b[index] === void 0) {
      return 1;
    }
    if (a[index] > b[index]) {
      return 1;
    }
    return -1;
  };
};

sortDescending = function(index) {
  return function(a, b) {
    if (b[index] === void 0) {
      return -1;
    }
    if (a[index] >= b[index]) {
      return -1;
    }
    return 1;
  };
};

updateRows = function(rows, patch) {
  var i, len, replaced, row;
  if (this.type === "DATUM") {
    throw Error("Expected type SEQUENCE but found DATUM");
  }
  if (!rows.length) {
    return {
      replaced: 0,
      unchanged: 0
    };
  }
  if (patch === null) {
    return {
      replaced: 0,
      unchanged: rows.length
    };
  }
  utils.expect(patch, "OBJECT");
  replaced = 0;
  for (i = 0, len = rows.length; i < len; i++) {
    row = rows[i];
    if (utils.update(row, patch)) {
      replaced += 1;
    }
  }
  return {
    replaced: replaced,
    unchanged: rows.length - replaced
  };
};

updateRow = function(row, patch) {
  if (this.type !== "SELECTION") {
    throw Error("Expected type SELECTION but found " + this.type);
  }
  if (row === null) {
    return {
      replaced: 0,
      skipped: 1
    };
  }
  if (utils.update(row, patch)) {
    return {
      replaced: 1,
      unchanged: 0
    };
  }
  return {
    replaced: 0,
    unchanged: 1
  };
};

deleteRows = function(rows) {
  var deleted;
  if (this.type !== "SEQUENCE") {
    throw Error("Expected type SEQUENCE but found " + this.type);
  }
  if (!rows.length) {
    return {
      deleted: 0
    };
  }
  deleted = 0;
  this.db._tables[this.tableId] = this.db._tables[this.tableId].filter(function(row) {
    if (~rows.indexOf(row)) {
      deleted += 1;
      return false;
    }
    return true;
  });
  return {
    deleted: deleted
  };
};

deleteRow = function(row) {
  if (row === null) {
    return {
      deleted: 0,
      skipped: 1
    };
  }
  if (this.type !== "SELECTION") {
    throw Error("Expected type SELECTION but found " + this.type);
  }
  this.db._tables[this.tableId].splice(this.rowIndex, 1);
  return {
    deleted: 1,
    skipped: 0
  };
};
