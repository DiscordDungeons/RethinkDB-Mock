// Generated by CoffeeScript 1.12.4
var Query, Table, assertType, clearTable, define, findRow, getRow, getRows, insertRows, isArray, isConstructor, methods, parseArgs, runQuery, setType, sliceArray, utils, uuid;

isConstructor = require("isConstructor");

assertType = require("assertType");

sliceArray = require("sliceArray");

setType = require("setType");

Query = require("./Query");

utils = require("./utils");

uuid = require("./utils/uuid");

isArray = Array.isArray;

parseArgs = Query.prototype._parseArgs;

runQuery = Query.prototype._run;

define = Object.defineProperty;

Table = function(db, tableId) {
  var query;
  query = function(key) {
    return Query(query, "TABLE").bracket(key);
  };
  query._db = db;
  query._type = "TABLE";
  query._tableId = tableId;
  return setType(query, Table);
};

methods = {};

methods["do"] = function(callback) {
  throw Error("Tables must be coerced to arrays before calling `do`");
};

methods.get = function(rowId) {
  var self;
  if (rowId === void 0) {
    throw Error("Cannot convert `undefined` with r.expr()");
  }
  self = Table(this._db, this._tableId);
  self._action = "get";
  self._rowId = rowId;
  return Query(self, "SELECTION");
};

methods.getAll = function() {
  var self;
  self = Table(this._db, this._tableId);
  self._action = "getAll";
  self._args = arguments;
  parseArgs.call(self);
  return Query(self, "SEQUENCE");
};

methods.insert = function(rows, options) {
  var self;
  self = Table(this._db, this._tableId);
  self._action = "insert";
  self._args = arguments;
  parseArgs.call(self);
  return Query(self, "DATUM");
};

methods["delete"] = function() {
  var self;
  self = Table(this._db, this._tableId);
  self._action = "delete";
  return Query(self, "DATUM");
};

"nth getField offsetsOf orderBy filter fold count limit slice merge pluck without update".split(" ").forEach(function(key) {
  methods[key] = function() {
    return Query(this, "TABLE")._then(key, arguments);
  };
});

methods.run = function() {
  return Promise.resolve().then(runQuery.bind(this));
};

methods.then = function(onFulfilled) {
  return this.run().then(onFulfilled);
};

methods._eval = function(ctx) {
  var args, table;
  ctx.type = this._type;
  ctx.tableId = this._tableId;
  if (!(table = this._db._tables[this._tableId])) {
    throw Error("Table `" + this._tableId + "` does not exist");
  }
  if (!this._action) {
    return table;
  }
  args = utils.resolve(this._args);
  switch (this._action) {
    case "get":
      return getRow(table, this._rowId, ctx);
    case "getAll":
      return getRows(table, args);
    case "insert":
      return insertRows(table, args[0], args[1]);
    case "delete":
      return clearTable(table);
  }
};

methods._run = runQuery;

Object.keys(methods).forEach(function(key) {
  return define(Table.prototype, key, {
    value: methods[key],
    writable: true
  });
});

module.exports = Table;

getRow = function(table, rowId, ctx) {
  var index;
  if (rowId === void 0) {
    throw Error("Argument 1 to get may not be `undefined`");
  }
  if (utils.isQuery(rowId)) {
    rowId = rowId._run();
  }
  if ((rowId === null) || isConstructor(rowId, Object)) {
    throw Error("Primary keys must be either a number, string, bool, pseudotype or array");
  }
  ctx.rowId = rowId;
  ctx.rowIndex = -1;
  index = -1;
  while (++index < table.length) {
    if (table[index].id === rowId) {
      ctx.rowIndex = index;
      return table[index];
    }
  }
  return null;
};

getRows = function(table, args) {
  var key;
  if (!args.length) {
    return [];
  }
  if (isConstructor(args[args.length - 1], Object)) {
    key = args.pop().index;
  }
  if (key == null) {
    key = "id";
  }
  utils.expect(key, "STRING");
  args.forEach(function(arg, index) {
    if (arg === null) {
      throw Error("Keys cannot be NULL");
    }
    if (isConstructor(arg, Object)) {
      throw Error((key === "id" ? "Primary" : "Secondary") + " keys must be either a number, string, bool, pseudotype or array");
    }
  });
  return table.filter(function(row) {
    var arg, i, len;
    for (i = 0, len = args.length; i < len; i++) {
      arg = args[i];
      if (isArray(arg)) {
        if (utils.equals(arg, row[key])) {
          return true;
        }
      } else if (arg === row[key]) {
        return true;
      }
    }
    return false;
  });
};

insertRows = function(table, rows) {
  var errors, generated_keys, i, len, res, row;
  if (!isArray(rows)) {
    rows = [rows];
  }
  errors = 0;
  generated_keys = [];
  for (i = 0, len = rows.length; i < len; i++) {
    row = rows[i];
    assertType(row, Object);
    if (row.hasOwnProperty("id")) {
      if (findRow(table, row.id)) {
        errors += 1;
      } else {
        table.push(row);
      }
    } else {
      generated_keys.push(row.id = uuid());
      table.push(row);
    }
  }
  res = {
    errors: errors
  };
  if (errors > 0) {
    res.first_error = "Duplicate primary key `id`";
  }
  res.inserted = rows.length - errors;
  if (generated_keys.length) {
    res.generated_keys = generated_keys;
  }
  return res;
};

findRow = function(table, rowId) {
  if (rowId === void 0) {
    throw Error("Argument 1 to get may not be `undefined`");
  }
  if (utils.isQuery(rowId)) {
    rowId = rowId._run();
  }
  if ((rowId === null) || isConstructor(rowId, Object)) {
    throw Error("Primary keys must be either a number, string, bool, pseudotype or array");
  }
  return table.find(function(row) {
    return row.id === rowId;
  });
};

clearTable = function(table) {
  var deleted;
  deleted = table.length;
  table.length = 0;
  return {
    deleted: deleted
  };
};
